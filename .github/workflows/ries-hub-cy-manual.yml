name: Ries Hub Cypress Manual

on:
  workflow_dispatch:
    inputs:
      tag:
        type: choice
        description: Tag of the tests you want to run
        required: true
        default: '@CI'
        options:
          - '@regression'
          - '@smoke'
          - '@CI'
      browser:
        type: choice
        description: Browser you want tests to run on
        default: 'chrome'
        required: true
        options:
          - chrome
          - firefox
      projects:
        type: choice
        description: Project you want to tests to run on
        default: 'ries-hub-ui-e2e'
        required: true
        options:
          - 'ries-hub-ui-e2e'
          - 'ries-hub-api-e2e'
      tests_per_machine:
        type: choice
        description: Number of tests to run on each machine
        required: true
        default: '4'
        options:
          - '1'
          - '2'
          - '3'
          - '4'
          - '5'
      configuration:
        type: choice
        description: preview build
        required: false
        default: 'stage'
        options:
          - 'stage'
          - 'master'
      version:
        type: string
        description: version number
        required: false
        default: '1.75.0'
      baseurl:
        type: string
        description: baseurl to run against
        required: false
        default: 'https://ries-hub-ui-master.awsdev.repsrv.com/'

env:
  NODE_VERSION: '20.12.1'

jobs:
  environment:
    runs-on: ubuntu-latest

    steps:
      - name: Inputs Received
        run: |
          echo '### Base branch' >> $GITHUB_STEP_SUMMARY
          echo "${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_STEP_SUMMARY
          echo '### Inputs' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo '${{ toJSON(inputs) }}' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  cy-prep:
    runs-on: ubuntu-latest
    outputs:
      author: ${{ steps.cy-info.outputs.author }}
      branch: ${{ github.ref_name }}
      browser: ${{ github.event.inputs.browser }}
      tag: ${{ github.event.inputs.tag }}
      configuration: ${{ github.event.inputs.configuration }}
      baseurl: ${{ github.event.inputs.baseurl }}
      instances: ${{ steps.instances.outputs.instances }}
      group: ${{ steps.instances.outputs.instances }}
      projects: ${{ github.event.inputs.projects }}
      build-id: ${{ steps.cy-info.outputs.build-id }}
      email: ${{ steps.cy-info.outputs.email }}
      message: ${{ steps.cy-info.outputs.message }}
      remote: ${{ steps.cy-info.outputs.remote }}
      sha: ${{ steps.cy-info.outputs.sha }}

    steps:
      - name: ‚úîÔ∏è Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üõ†Ô∏è Setup Node.js and Install Dependencies
        uses: ./.github/actions/setup-node-install
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: üéÅ Get Affected Base
        id: base
        run: |
          BASE="remotes/origin/master"
          echo "name=${BASE}" >> $GITHUB_OUTPUT

      - name: üéÅ Get Necessary Cypress information
        id: cy-info
        run: |
          AUTHOR=$(git log -1 --pretty=%an)
          EMAIL=$(git log -1 --pretty=%ae)
          BROWSER="${{ github.event.inputs.browser }}"
          TAG="${{ github.event.inputs.tag }}"
          PROJECTS="${{ github.event.inputs.projects }}"
          REMOTE=$(git config --get remote.origin.url)
          SHA=$(git log -1 --pretty=%H)

          echo "Looking for spec files with tag: ${TAG}"
          echo "In project directory: apps/${PROJECTS}"

          # First find all spec files (properly grouping the -name conditions)
          ALL_SPECS=$(find "apps/${PROJECTS}" -type f \( -name "*.cy.ts" -o -name "*.spec.ts" \))
          echo "All spec files found:"
          echo "$ALL_SPECS"
          echo "Total spec files: $(echo "$ALL_SPECS" | wc -l)"

          # Then filter for ones with the tag
          SPECS=$(echo "$ALL_SPECS" | while read -r file; do
            if [ -f "$file" ] && grep -l "${TAG}" "$file" > /dev/null; then
              echo "$file"
            fi
          done | tr '\n' ',' | sed 's/,$//')

          echo "Spec files with tag ${TAG}:"
          echo "$SPECS" | tr ',' '\n'
          echo "Total matching specs: $(echo "$SPECS" | tr ',' '\n' | wc -l)"

          echo "author=${AUTHOR}" >> $GITHUB_OUTPUT
          echo "email=${EMAIL}" >> $GITHUB_OUTPUT
          echo "build-id=sha-${SHA}-time-$(date +"%s")" >> $GITHUB_OUTPUT
          echo "projects=${PROJECTS}" >> $GITHUB_OUTPUT
          echo "remote=${REMOTE}" >> $GITHUB_OUTPUT
          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          echo "browser=${BROWSER}" >> $GITHUB_OUTPUT
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "message<<$EOF" >> $GITHUB_OUTPUT
          git log -1 --pretty=%B >> $GITHUB_OUTPUT
          echo "$EOF" >> $GITHUB_OUTPUT
          echo "specs=${SPECS}" >> $GITHUB_OUTPUT

      - name: ‚ôæÔ∏è Set Instances
        id: instances
        run: |
          # Debug information
          echo "Debug: Starting Set Instances"
          echo "TESTS_PER_MACHINE: ${{ github.event.inputs.tests_per_machine }}"
          echo "SPECS: ${{ steps.cy-info.outputs.specs }}"

          # If no specs found, create just one instance
          if [ -z "${{ steps.cy-info.outputs.specs }}" ]; then
            echo "No specs found, creating single instance"
            echo "instances=[\"machine1\"]" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Count the number of spec files
          IFS=',' read -ra SPEC_ARRAY <<< "${{ steps.cy-info.outputs.specs }}"
          SPEC_COUNT=${#SPEC_ARRAY[@]}
          echo "Number of spec files found: $SPEC_COUNT"

          # Calculate number of machines needed (ceiling division)
          TESTS_PER_MACHINE=${{ github.event.inputs.tests_per_machine }}
          NUM_MACHINES=$(( (SPEC_COUNT + TESTS_PER_MACHINE - 1) / TESTS_PER_MACHINE ))

          echo "Number of spec files: $SPEC_COUNT"
          echo "Tests per machine: $TESTS_PER_MACHINE"
          echo "Number of machines needed: $NUM_MACHINES"

          # Create instance array
          INSTANCES="["
          for (( i=1; i<=$NUM_MACHINES; i++ )); do
            if [ $i -eq $NUM_MACHINES ]; then
              INSTANCES+="\"machine$i\""
            else
              INSTANCES+="\"machine$i\","
            fi
          done
          INSTANCES+="]"

          echo "Final machines configuration: $INSTANCES"
          echo "instances=${INSTANCES}" >> $GITHUB_OUTPUT

  cypress-tests:
    name: cypress-tests (${{ matrix.GROUP_VARS }})
    needs: [cy-prep]
    runs-on:
      group: self-hosted-nonprod
      labels: nonprod
    strategy:
      fail-fast: false
      matrix:
        GROUP_VARS: ${{ fromJSON(needs.cy-prep.outputs.instances) }}

    steps:
      - name: Process Build Id
        id: build-id
        run: |
          PROJECT="${{ needs.cy-prep.outputs.projects }}"
          BUILD_ID="${{ needs.cy-prep.outputs.build-id }}"
          echo "build-id=${PROJECT}-${BUILD_ID}" >> $GITHUB_OUTPUT

      - name: üñ®Ô∏è Print needed info
        run: |
          echo "Needed Information"
          echo "author: ${{ needs.cy-prep.outputs.author }}"
          echo "branch: ${{ github.ref_name }}"
          echo "build-id": ${{ steps.build-id.outputs.build-id }}
          echo "email: ${{ needs.cy-prep.outputs.email }}"
          echo "env: ${{ github.event.inputs.test_env }}"
          echo "message: ${{ needs.cy-prep.outputs.message }}"
          echo "project: ${{ github.event.inputs.projects }}"
          echo "configuration: ${{ matrix.GROUP_VARS }}"
          echo "remote: ${{ needs.cy-prep.outputs.remote }}"
          echo "sha: ${{ needs.cy-prep.outputs.sha }}"
          echo "record key: ${{ needs.cy-prep.outputs.record-key }}"
          echo "stage: ${{ matrix.GROUP_VARS }}"
          echo "browser: ${{ github.event.inputs.browser }}"
          echo "tag: ${{ github.event.inputs.tag }}"

      - name: üéÅ Cypress Cloud Record Key Secret Name
        id: cy-cloud
        run: |
          RECORD_KEY=$(echo "${{github.event.inputs.projects}}_RECORD_KEY" | sed -e "s/-/_/g" | tr '[:lower:]' '[:upper:]')
          echo "RECORD_KEY: ${RECORD_KEY}"
          echo "record-key=${RECORD_KEY}" >> $GITHUB_OUTPUT

      - name: ‚úîÔ∏è Checkout
        uses: actions/checkout@v4

      - name: üõ†Ô∏è Setup Node.js and Install Dependencies
        uses: ./.github/actions/setup-node-install
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: üß™ Cypress Tests (UI) [RIES Hub]
        if: ${{ startsWith(needs.cy-prep.outputs.projects, 'ries-hub-') && endsWith(needs.cy-prep.outputs.projects, '-e2e') }}
        id: cypress-ries
        env:
          AUTHOR: ${{ needs.cy-prep.outputs.author }}
          BRANCH: ${{ needs.cy-prep.outputs.branch }}
          BUILD_ID: ${{ steps.build-id.outputs.build-id }}
          EMAIL: ${{ needs.cy-prep.outputs.email }}
          MESSAGE: ${{ needs.cy-prep.outputs.message }}
          PROJECT: ${{ needs.cy-prep.outputs.projects }}
          CONFIGURATION: ${{ github.event.inputs.configuration }}
          REMOTE: ${{ needs.cy-prep.outputs.remote }}
          REPUBLIC_SYSTEM_PAT: ${{ secrets.REPUBLIC_SYSTEM_PAT }}
          SHA: ${{ needs.cy-prep.outputs.sha }}
          TAG: ${{ needs.cy-prep.outputs.tag }}
          STAGE: ${{ github.event.inputs.configuration }}
          AWS_ACCESS_KEY_ID: ${{ env.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ env.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_DEFAULT_REGION }}
          AUTH0_AUDIENCE: ${{ secrets.AUTH0_AUDIENCE }}
          AUTH0_MANAGEMENT_AUDIENCE: ${{ secrets.AUTH0_MANAGEMENT_AUDIENCE }}
          AUTH0_BASEURL: ${{ secrets.AUTH0_BASEURL }}
          AUTH0_CLIENT_ID: ${{ secrets.AUTH0_CLIENT_ID }}
          AUTH0_SECRET: ${{ secrets.AUTH0_SECRET }}
          AUTH0_CONNECTION: ${{ secrets.AUTH0_CONNECTION }}
          AUTH0_ID_PREPEND: ${{ secrets.AUTH0_ID_PREPEND }}
          AUTH0_MANAGEMENT_API_PATH: ${{ secrets.AUTH0_MANAGEMENT_API_PATH }}
          AUTH0_SCOPE_BASE: ${{ secrets.AUTH0_SCOPE_BASE }}
          AUTH0_SCOPE_READ: ${{ secrets.AUTH0_SCOPE_READ }}
          AUTH0_USER_DATA_NAMESPACE: ${{ secrets.AUTH0_USER_DATA_NAMESPACE }}
          RECORD_KEY: ${{ secrets[steps.cy-cloud.outputs.record-key] }}
          CONFIG: ${{ github.event.inputs.configuration }}
          VERSION: ${{ github.event.inputs.version }}
          GROUP_VARS: ${{ matrix.GROUP_VARS }}
          SPECS: ${{ needs.cy-prep.outputs.specs }}

        run: |
          # Set base URL based on project type and input baseUrl
          BASE_URL="${{ needs.cy-prep.outputs.baseurl }}"

          # If version is provided, replace dots with hyphens and then replace 'master' with 'release-hub-{version}'
          if [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION=$(echo "${{ github.event.inputs.version }}" | sed 's/\./-/g')
            BASE_URL=$(echo "${BASE_URL}" | sed "s/master/release-hub-${VERSION}/")
          fi

          if [[ "${PROJECT}" == *"-api-"* ]]; then
            # Replace 'ui' with 'api' in the baseUrl
            BASE_URL=$(echo "${BASE_URL}" | sed 's/ries-hub-ui/ries-hub-api/')
          fi

          echo "Using BASE_URL: ${BASE_URL}"

          # Run Cypress with parallel execution
            npx nx e2e ${PROJECT} -- \
              --stage=${STAGE} \
              --env.grepTags=${TAG} \
              --env.configuration=${CONFIG} \
              --env.version=${VERSION} \
              --skipServe=true \
              ${CONFIGURATION:+"--configuration $CONFIGURATION"} \
              --record \
              --key=${RECORD_KEY} \
              --parallel \
              --ci-build-id ${BUILD_ID} \
              --group "CI" \
              --spec "${SPECS}" \
              --baseUrl="${BASE_URL}" \
              --config experimentalRunAllSpecs=false | tee cypress-output.log

      - name: Debug Before Upload
        if: ${{ !cancelled() }}
        continue-on-error: true
        run: |
          echo "Matrix GROUP_VARS value: ${{ matrix.GROUP_VARS }}"
          echo "Looking for reports in:"
          find apps/${{ needs.cy-prep.outputs.projects }}/reports/run-${{ matrix.GROUP_VARS }}/.jsons -name "mochawesome*.json" -ls || echo "No files found in initial search"

      # Create a directory and copy files there before upload
      - name: Prepare Files for Upload
        if: ${{ !cancelled() }}
        continue-on-error: true
        env:
          PROJECT: ${{ needs.cy-prep.outputs.projects }}
          GROUP_VARS: ${{ matrix.GROUP_VARS }}
        run: |
          UPLOAD_DIR="reports-to-upload"
          mkdir -p $UPLOAD_DIR
          REPORT_DIR="apps/${PROJECT}/reports/run-${GROUP_VARS}/.jsons"

          echo "Looking for report files in: ${REPORT_DIR}"

          # Try to find and copy files, but don't fail if none found
          if [ -d "${REPORT_DIR}" ] && find "${REPORT_DIR}" -name "mochawesome*.json" -exec cp {} $UPLOAD_DIR/ \; ; then
            echo "Files copied successfully"
            echo "Copied files:"
            ls -la $UPLOAD_DIR/
          else
            echo "No files found to copy in ${REPORT_DIR}"
            # Create a dummy report if no tests were run
            echo '{"stats":{"suites":0,"tests":0,"passes":0,"pending":0,"failures":0,"start":"'$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")'","end":"'$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")'","duration":0,"passPercent":0,"pendingPercent":0},"results":[]}' > "$UPLOAD_DIR/mochawesome_no_tests.json"
          fi

          echo "Files ready for upload:"
          ls -la $UPLOAD_DIR/

      - name: Upload Reports
        if: ${{ !cancelled() }}
        uses: actions/upload-artifact@v4
        with:
          name: cypress-reports-${{ matrix.GROUP_VARS }}
          path: reports-to-upload/*.json
          if-no-files-found: error

  merge-all-reports:
    needs: cypress-tests
    runs-on: ubuntu-latest
    if: ${{ !cancelled() }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: cypress-reports-*
          merge-multiple: true
          path: downloaded-reports

      - name: Debug Downloaded Files
        run: |
          echo "Current directory structure:"
          pwd
          ls -R downloaded-reports

      - name: üñ•Ô∏è Setup Node Version
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install Dependencies
        run: |
          npm install -g mochawesome-merge mochawesome-report-generator
          sudo apt-get update && sudo apt-get install -y jq

      - name: Merge Reports
        run: |
          # Ensure json-files directory exists
          mkdir -p json-files

          # Copy all JSON files to the json-files directory
          find downloaded-reports -name "*.json" -exec cp {} json-files/ \;

          echo "Files to be merged:"
          ls -l json-files/

          # Create reports directory
          mkdir -p reports

          # Merge the reports and save as index.json
          mochawesome-merge "json-files/*.json" > "reports/index.json"

          # Generate HTML report
          marge reports/index.json --reportDir merged-report --inline

      - name: Debug Report File
        run: |
          echo "Current directory contents:"
          ls -la
          echo "\nVerifying report file exists:"
          if [ -f "reports/index.json" ]; then
            echo "Report file exists"
            echo "File size: $(stat -f%z reports/index.json) bytes"
          else
            echo "Report file does not exist"
            echo "Contents of current directory:"
            find . -type f -name "*.json"
          fi

      - name: Upload Merged Report
        uses: actions/upload-artifact@v4
        with:
          name: merged-cypress-report
          path: |
            reports/index.json
            merged-report/*

      - name: Set Opslevel Service Name
        id: opslevel-service-var
        run: |
          # Transform all dashes to underscores in the service name
          SERVICE_NAME=$(echo "${{ github.event.inputs.projects }}" | sed 's/-/_/g')
          echo "Service name will be: ${SERVICE_NAME}"
          echo "OPSLEVEL_SERVICE=${SERVICE_NAME}" >> $GITHUB_OUTPUT

      - name: Format Report for Opslevel
        run: |
          if [ -f "reports/index.json" ]; then
            echo "Debug: File exists, checking content..."

            # Print file size and first few lines
            echo "File size: $(wc -c < reports/index.json) bytes"
            echo "First 10 lines of file:"
            head -n 10 reports/index.json

            echo "Debug: Attempting to validate JSON structure..."
            if ! jq '.' reports/index.json > /dev/null 2>&1; then
              echo "Error: Invalid JSON detected. Attempting to fix common issues..."

              # Try to fix common JSON issues
              # 1. Remove any BOM characters
              sed -i '1s/^\xEF\xBB\xBF//' reports/index.json

              # 2. Check if it's multiple JSON objects concatenated
              echo "Checking for multiple JSON objects..."
              if grep -q "}{" reports/index.json; then
                echo "Found multiple concatenated JSON objects, attempting to fix..."
                # Wrap in array if multiple objects found
                sed -i '1i[' reports/index.json
                sed -i 's/}{/},{/g' reports/index.json
                echo "]" >> reports/index.json
              fi

              # Verify if fix worked
              if ! jq '.' reports/index.json > /dev/null 2>&1; then
                echo "Error: JSON is still invalid after attempted fixes"
                echo "Full file contents:"
                cat reports/index.json
                exit 1
              fi
            fi

            echo "Debug: JSON is valid, examining structure..."
            echo "Top level keys:"
            jq -r 'keys' reports/index.json || echo "Failed to get top level keys"

            echo "Debug: Checking if array or object..."
            if jq -e 'type' reports/index.json > /dev/null 2>&1; then
              echo "Document type: $(jq -r 'type' reports/index.json)"
            else
              echo "Failed to determine document type"
            fi

            # If it's an array, merge the objects
            if [ "$(jq -r 'type' reports/index.json)" = "array" ]; then
              echo "Converting array to single object..."
              jq -s 'reduce .[] as $item ({}; . * $item)' reports/index.json > reports/temp.json
              mv reports/temp.json reports/index.json
            fi

            echo "Debug: Processing report..."
            jq -r '
            def debug_counts:
              . as $root |
              if has("results") then
                (.results | length) as $results_count |
                (.results | map(select(.suites) | .suites | length) | add // 0) as $suites_count |
                (.results | map(.suites // [] | map(.tests // [] | length) | add) | add // 0) as $tests_count |
                "Results count: \($results_count)\nTotal suites: \($suites_count)\nTotal tests: \($tests_count)"
              elif has("stats") then
                "Has stats but no results array\nStats: \(.stats)"
              else
                "No results or stats found\nAvailable keys: \(keys)"
              end;

            def count_actual_tests:
              [.results // [] | .[] | .suites // [] | .[] | .tests // [] | .[] | select(.title != null and (.state == "passed" or .state == "failed" or .state == "pending"))] | length;

            def count_passed_tests:
              [.results // [] | .[] | .suites // [] | .[] | .tests // [] | .[] | select(.state == "passed")] | length;

            def count_pending_tests:
              [.results // [] | .[] | .suites // [] | .[] | .tests // [] | .[] | select(.state == "pending")] | length;

            def count_failed_tests:
              [.results // [] | .[] | .suites // [] | .[] | .tests // [] | .[] | select(.state == "failed")] | length;

            def count_suites:
              [.results // [] | .[] | .suites // [] | .[] | select(.title != null)] | length;

            # Print debug information
            debug_counts |

            # Create the final output
            {
              metric: {
                suites: count_suites,
                tests: count_actual_tests,
                passes: count_passed_tests,
                pending: count_pending_tests,
                failures: count_failed_tests,
                start: (.stats.start // null),
                end: (.stats.end // null),
                duration: (.stats.duration // 0),
                passPercent: (if count_actual_tests > 0 then (count_passed_tests / count_actual_tests * 100) else 0 end),
                pendingPercent: (if count_actual_tests > 0 then (count_pending_tests / count_actual_tests * 100) else 0 end)
              },
              service: ${{ toJSON(steps.opslevel-service-var.outputs.OPSLEVEL_SERVICE) }}
            }' reports/index.json > reports/opslevel.json || {
              echo "Error processing JSON. Dumping diagnostic information:"
              echo "File contents type: $(file reports/index.json)"
              echo "File encoding: $(file -i reports/index.json)"
              echo "Line count: $(wc -l reports/index.json)"
              echo "First 100 lines:"
              head -n 100 reports/index.json
              exit 1
            }

            echo "Debug: Final formatted report for Opslevel:"
            cat reports/opslevel.json || echo "Error reading final report"

            # Replace the original report with the formatted one
            mv reports/opslevel.json reports/index.json
          else
            echo "Report file not found at reports/index.json!"
            echo "Current directory contents:"
            ls -la reports/ || echo "Reports directory not found"
            exit 1
          fi

      - name: Report Cypress To Opslevel
        if: ${{ !cancelled() }}
        uses: RepublicServicesRepository/gha-cypress_to_opslevel@latest
        with:
          run-type: regression
          opslevel-service: ${{ steps.opslevel-service-var.outputs.OPSLEVEL_SERVICE }}
          report-path: reports/index.json
          parallel: false

  cypress-status:
    if: ${{ !cancelled() }}
    needs: [cy-prep, cypress-tests]
    runs-on: ubuntu-latest
    steps:
      - name: üñ®Ô∏è print cypress-smoke-tests result
        run: |
          echo "has-projects: ${{ needs.cy-prep.outputs.has-projects }}"
          echo "result: ${{ needs.cypress-tests.result }}"
          echo "proceed: ${{ needs.cy-prep.outputs.has-projects == 'false' || needs.cypress-tests.result == 'success' }}"

      - name: ‚úîÔ∏è Check Cypress Matrix status
        if: ${{ needs.cy-prep.outputs.has-projects == 'true' && needs.cypress-tests.result != 'success' }}
        run: exit 1
